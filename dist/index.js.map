{"mappings":";;;;;;;;ACAA;;;;;CAKC,GAED,MAAM,aAAE,+BAAS,EAAE,GAAG;AAEf,MAAM;IACX,OAAO,UAAU,EAAC;IAEV,QAAY;IACZ,iBAAoC;IACpC,UAAuB;IAEvB,UAAU;QAChB,IAAI,CAAC,gBAAgB,CAAE,IAAI,CAAC,OAAO,CAAC,MAAM;IAC5C,EAAC;IAEO,SAAS;QACf,MAAM,KAAK,IAAI,CAAC,OAAO,CAAC,MAAM;QAC9B,MAAM,QAAQ,GAAG,iBAAiB,CAAC,WAAW;YAAE,SAAS;QAAK;IAC9D,4DAA4D;IAC9D,EAAC;IAEQ,KAAY;IAErB,YAAY,IAAY,CAAE;QACxB,IAAI,CAAC,IAAI,GAAG;QACZ,MAAM,UAAU,gCAAU,IAAI,CAAC,MAAM,0CAAe,OAAO;QAC3D,QAAQ,SAAS,GAAG,IAAI,CAAC,OAAO;QAChC,QAAQ,eAAe,GAAG,IAAI,CAAC,MAAM;QAErC,IAAI,CAAC,SAAS,GAAG,IAAI,QAAQ,CAAC;YAC5B,IAAI,CAAC,gBAAgB,GAAG;QAC1B;QAEA,IAAI,CAAC,OAAO,GAAG;IACjB;IAEA,MAAc,SACZ,MAAmE,EACnE,KAAW,EACG;QACd,MAAM,KAAK,MAAM,IAAI,CAAC,SAAS;QAC/B,MAAM,KAAK,GAAG,WAAW,CACvB,WACA;YAAC;YAAO;YAAS;SAAS,CAAC,QAAQ,CAAC,UAAU,cAAc;QAE9D,MAAM,QAAQ,GAAG,WAAW,CAAC;QAC7B,OAAO,IAAI,QAAQ,CAAC,SAAS;YAC3B,MAAM,MAAM,KAAK,CAAC,OAAO,CAAC;YAC1B,IAAI,SAAS,GAAG,IACd,QAAQ,IAAI,MAAM,EAAE,SAAS,OAAO,IAAI,MAAM,CAAC,KAAK,GAAG,IAAI,MAAM;YACnE,IAAI,OAAO,GAAG,IAAM,OAAO,IAAI,KAAK;QACtC;IACF;IAEA,MAAM,QAAQ,EAAU,EAAE,KAAU,EAAiB;QACnD,OAAO,IAAI,CAAC,QAAQ,CAAC,OAAO;gBAAE;mBAAI;QAAM;IAC1C;IAEA,MAAM,QAAQ,EAAU,EAA4B;QAClD,OAAO,IAAI,CAAC,QAAQ,CAAC,OAAO;IAC9B;IAEA,MAAM,QAAyB;QAC7B,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB;IAEA,MAAM,UAA6B;QACjC,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB;IAEA,MAAM,OAAO,EAAU,EAAiB;QACtC,OAAO,IAAI,CAAC,QAAQ,CAAC,UAAU;IACjC;IAEA,MAAM,QAAuB;QAC3B,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB;AACF;AAEO,MAAM,4CAAiB,IAAI,0CAAe","sources":["src/index.ts","src/indexed-storage.ts"],"sourcesContent":["export * from './indexed-storage'\n","/**\n * Minimal Wrapper for indexedDB\n *\n * Based on this gist\n * https://gist.github.com/JamesMessinger/a0d6389a5d0e3a24814b\n */\n\nconst { indexedDB } = window\n\nexport class IndexedStorage {\n  static VERSION = 1\n\n  private request: any\n  private promiseFulfilled?: (db: any) => void\n  private dbPromise: Promise<any>\n\n  private success = () => {\n    this.promiseFulfilled!(this.request.result)\n  }\n\n  private update = () => {\n    const db = this.request.result\n    const store = db.createObjectStore('objects', { keyPath: 'id' })\n    // store.createIndex(\"NameIndex\", ['_created', '_modified'])\n  }\n\n  readonly name: string\n\n  constructor(name: string) {\n    this.name = name\n    const request = indexedDB.open(name, IndexedStorage.VERSION)\n    request.onsuccess = this.success\n    request.onupgradeneeded = this.update\n\n    this.dbPromise = new Promise((resolve) => {\n      this.promiseFulfilled = resolve\n    })\n\n    this.request = request\n  }\n\n  private async dispatch(\n    method: 'put' | 'get' | 'count' | 'getAllKeys' | 'clear' | 'delete',\n    value?: any\n  ): Promise<any> {\n    const db = await this.dbPromise\n    const tx = db.transaction(\n      'objects',\n      ['put', 'clear', 'delete'].includes(method) ? 'readwrite' : 'readonly'\n    )\n    const store = tx.objectStore('objects')\n    return new Promise((resolve, reject) => {\n      const req = store[method](value)\n      req.onsuccess = () =>\n        resolve(req.result?.value != null ? req.result.value : req.result)\n      req.onerror = () => reject(req.error)\n    })\n  }\n\n  async setItem(id: string, value: any): Promise<void> {\n    return this.dispatch('put', { id, value })\n  }\n\n  async getItem(id: string): Promise<any | undefined> {\n    return this.dispatch('get', id)\n  }\n\n  async count(): Promise<number> {\n    return this.dispatch('count')\n  }\n\n  async allKeys(): Promise<string[]> {\n    return this.dispatch('getAllKeys')\n  }\n\n  async delete(id: string): Promise<void> {\n    return this.dispatch('delete', id)\n  }\n\n  async clear(): Promise<void> {\n    return this.dispatch('clear')\n  }\n}\n\nexport const indexedStorage = new IndexedStorage('default-local-db')\n"],"names":[],"version":3,"file":"index.js.map"}