{"mappings":";;;;;;;ACAA;;;;;CAKC,GAED,MAAM,aAAE,+BAAS,EAAE,GAAG;AAEf,MAAM;IACX,OAAO,UAAU,EAAC;IAEV,QAAY;IACZ,iBAAoC;IACpC,UAAuB;IAEvB,UAAU;QAChB,IAAI,CAAC,iBAAkB,IAAI,CAAC,QAAQ;IACtC,EAAC;IAEO,SAAS;QACf,MAAM,KAAK,IAAI,CAAC,QAAQ;QACxB,MAAM,QAAQ,GAAG,kBAAkB,WAAW;YAAE,SAAS;QAAK;IAC9D,4DAA4D;IAC9D,EAAC;IAEO,MAAa;IAErB,IAAI,OAAe;QACjB,OAAO,IAAI,CAAC;IACd;IAEA,YAAY,IAAY,CAAE;QACxB,IAAI,CAAC,QAAQ;QACb,MAAM,UAAU,gCAAU,KAAK,MAAM,0CAAe;QACpD,QAAQ,YAAY,IAAI,CAAC;QACzB,QAAQ,kBAAkB,IAAI,CAAC;QAE/B,IAAI,CAAC,YAAY,IAAI,QAAQ,CAAC;YAC5B,IAAI,CAAC,mBAAmB;QAC1B;QAEA,IAAI,CAAC,UAAU;IACjB;IAEA,MAAM,QAAQ,EAAU,EAAE,KAAU,EAAiB;QACnD,MAAM,KAAK,MAAM,IAAI,CAAC;QACtB,MAAM,KAAK,GAAG,YAAY,WAAW;QACrC,MAAM,QAAQ,GAAG,YAAY;QAC7B,OAAO,IAAI,QAAQ,CAAC;YAClB,MAAM,MAAM,MAAM,IAAI;oBAAE;uBAAI;YAAM;YAClC,IAAI,YAAY;QAClB;IACF;IAEA,MAAM,QAAQ,EAAU,EAA4B;QAClD,MAAM,KAAK,MAAM,IAAI,CAAC;QACtB,MAAM,KAAK,GAAG,YAAY,WAAW;QACrC,MAAM,QAAQ,GAAG,YAAY;QAC7B,OAAO,IAAI,QAAQ,CAAC;YAClB,MAAM,MAAM,MAAM,IAAI;YACtB,IAAI,YAAY;gBACd,QAAQ,IAAI,QAAQ,SAAS,OAAO,IAAI,OAAO,QAAQ;YACzD;QACF;IACF;IAEA,MAAM,QAAyB;QAC7B,MAAM,KAAK,MAAM,IAAI,CAAC;QACtB,MAAM,KAAK,GAAG,YAAY,WAAW;QACrC,MAAM,QAAQ,GAAG,YAAY;QAC7B,OAAO,IAAI,QAAQ,CAAC;YAClB,MAAM,MAAM,MAAM;YAClB,IAAI,YAAY;gBACd,QAAQ,IAAI;YACd;QACF;IACF;IAEA,MAAM,UAA2B;QAC/B,MAAM,KAAK,MAAM,IAAI,CAAC;QACtB,MAAM,KAAK,GAAG,YAAY,WAAW;QACrC,MAAM,QAAQ,GAAG,YAAY;QAC7B,OAAO,IAAI,QAAQ,CAAC;YAClB,MAAM,MAAM,MAAM;YAClB,IAAI,YAAY;gBACd,QAAQ,IAAI;YACd;QACF;IACF;IAEA,MAAM,OAAO,EAAU,EAAiB;QACtC,MAAM,KAAK,MAAM,IAAI,CAAC;QACtB,MAAM,KAAK,GAAG,YAAY,WAAW;QACrC,MAAM,QAAQ,GAAG,YAAY;QAC7B,OAAO,IAAI,QAAQ,CAAC;YAClB,MAAM,MAAM,MAAM,OAAO;YACzB,IAAI,YAAY;QAClB;IACF;IAEA,MAAM,QAAuB;QAC3B,MAAM,KAAK,MAAM,IAAI,CAAC;QACtB,MAAM,KAAK,GAAG,YAAY,WAAW;QACrC,MAAM,QAAQ,GAAG,YAAY;QAC7B,OAAO,IAAI,QAAQ,CAAC;YAClB,MAAM,MAAM,MAAM;YAClB,IAAI,YAAY;QAClB;IACF;AACF;AAEO,MAAM,4CAAiB,IAAI,0CAAe","sources":["src/index.ts","src/indexed-storage.ts"],"sourcesContent":["export * from './indexed-storage'\n","/**\n * Minimal Wrapper for indexedDB\n *\n * Based on this gist\n * https://gist.github.com/JamesMessinger/a0d6389a5d0e3a24814b\n */\n\nconst { indexedDB } = window\n\nexport class IndexedStorage {\n  static VERSION = 1\n\n  private request: any\n  private promiseFulfilled?: (db: any) => void\n  private dbPromise: Promise<any>\n\n  private success = () => {\n    this.promiseFulfilled!(this.request.result)\n  }\n\n  private update = () => {\n    const db = this.request.result\n    const store = db.createObjectStore('objects', { keyPath: 'id' })\n    // store.createIndex(\"NameIndex\", ['_created', '_modified'])\n  }\n\n  private _name: string\n\n  get name(): string {\n    return this._name\n  }\n\n  constructor(name: string) {\n    this._name = name\n    const request = indexedDB.open(name, IndexedStorage.VERSION)\n    request.onsuccess = this.success\n    request.onupgradeneeded = this.update\n\n    this.dbPromise = new Promise((resolve) => {\n      this.promiseFulfilled = resolve\n    })\n\n    this.request = request\n  }\n\n  async setItem(id: string, value: any): Promise<void> {\n    const db = await this.dbPromise\n    const tx = db.transaction('objects', 'readwrite')\n    const store = tx.objectStore('objects')\n    return new Promise((resolve) => {\n      const req = store.put({ id, value })\n      req.onsuccess = resolve\n    })\n  }\n\n  async getItem(id: string): Promise<any | undefined> {\n    const db = await this.dbPromise\n    const tx = db.transaction('objects', 'readwrite')\n    const store = tx.objectStore('objects')\n    return new Promise((resolve) => {\n      const req = store.get(id)\n      req.onsuccess = () => {\n        resolve(req.result?.value != null ? req.result.value : undefined)\n      }\n    })\n  }\n\n  async count(): Promise<number> {\n    const db = await this.dbPromise\n    const tx = db.transaction('objects', 'readwrite')\n    const store = tx.objectStore('objects')\n    return new Promise((resolve) => {\n      const req = store.count()\n      req.onsuccess = () => {\n        resolve(req.result)\n      }\n    })\n  }\n\n  async allKeys(): Promise<number> {\n    const db = await this.dbPromise\n    const tx = db.transaction('objects', 'readwrite')\n    const store = tx.objectStore('objects')\n    return new Promise((resolve) => {\n      const req = store.getAllKeys()\n      req.onsuccess = () => {\n        resolve(req.result)\n      }\n    })\n  }\n\n  async delete(id: string): Promise<void> {\n    const db = await this.dbPromise\n    const tx = db.transaction('objects', 'readwrite')\n    const store = tx.objectStore('objects')\n    return new Promise((resolve) => {\n      const req = store.delete(id)\n      req.onsuccess = resolve\n    })\n  }\n\n  async clear(): Promise<void> {\n    const db = await this.dbPromise\n    const tx = db.transaction('objects', 'readwrite')\n    const store = tx.objectStore('objects')\n    return new Promise((resolve) => {\n      const req = store.clear()\n      req.onsuccess = resolve\n    })\n  }\n}\n\nexport const indexedStorage = new IndexedStorage('default-local-db')\n"],"names":[],"version":3,"file":"index.js.map"}