function e(e,t,r,s){Object.defineProperty(e,t,{get:r,set:s,enumerable:!0,configurable:!0})}var t={};e(t,"IndexedStorage",()=>s),e(t,"indexedStorage",()=>o);let{indexedDB:r}=window;class s{static VERSION=1;request;promiseFulfilled;dbPromise;success=()=>{this.promiseFulfilled(this.request.result)};update=()=>{this.request.result.createObjectStore("objects",{keyPath:"id"})};name;constructor(e){this.name=e;let t=r.open(e,s.VERSION);t.onsuccess=this.success,t.onupgradeneeded=this.update,this.dbPromise=new Promise(e=>{this.promiseFulfilled=e}),this.request=t}async setItem(e,t){let r=(await this.dbPromise).transaction("objects","readwrite").objectStore("objects");return new Promise((s,o)=>{let a=r.put({id:e,value:t});a.onsuccess=()=>s(),a.onerror=()=>o(a.error)})}async getItem(e){let t=(await this.dbPromise).transaction("objects","readonly").objectStore("objects");return new Promise((r,s)=>{let o=t.get(e);o.onsuccess=()=>{r(o.result?.value!=null?o.result.value:void 0)},o.onerror=()=>s(o.error)})}async count(){let e=(await this.dbPromise).transaction("objects","readonly").objectStore("objects");return new Promise((t,r)=>{let s=e.count();s.onsuccess=()=>{t(s.result)},s.onerror=()=>r(s.error)})}async allKeys(){let e=(await this.dbPromise).transaction("objects","readonly").objectStore("objects");return new Promise((t,r)=>{let s=e.getAllKeys();s.onsuccess=()=>{t(s.result)},s.onerror=()=>r(s.error)})}async delete(e){let t=(await this.dbPromise).transaction("objects","readwrite").objectStore("objects");return new Promise((r,s)=>{let o=t.delete(e);o.onsuccess=r,o.onerror=()=>s(o.error)})}async clear(){let e=(await this.dbPromise).transaction("objects","readwrite").objectStore("objects");return new Promise((t,r)=>{let s=e.clear();s.onsuccess=t,s.onerror=()=>r(s.error)})}}let o=new s("default-local-db");export{s as IndexedStorage,o as indexedStorage};
//# sourceMappingURL=index.js.map
